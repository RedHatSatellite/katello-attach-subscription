#!/usr/bin/env ruby

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA 02110-1301, USA.

require 'optparse'
require 'yaml'
require 'apipie-bindings'

@defaults = {
  :noop      => false,
  :uri       => 'https://localhost/',
  :user      => 'admin',
  :pass      => 'changeme',
  :org       => 1,
}

@options = {
  :yamlfile  => 'katello-attach-subscription.yaml',
}

optparse = OptionParser.new do |opts|
  opts.banner = "Usage: #{opts.program_name} [options]"
  opts.version = "0.1"

  opts.on("-U", "--uri=URI", "URI to the Satellite") do |u|
    @options[:uri] = u
  end
  opts.on("-u", "--user=USER", "User to log in to Satellite") do |u|
    @options[:user] = u
  end
  opts.on("-p", "--pass=PASS", "Password to log in to Satellite") do |p|
    @options[:pass] = p
  end
  opts.on("-o", "--organization-id=ID", "ID of the Organization") do |o|
    @options[:org] = o
  end
  opts.on("-c", "--config=FILE", "configuration in YAML format") do |c|
    @options[:yamlfile] = c
  end
  opts.on("-n", "--noop", "do not actually execute anything") do
    @options[:noop] = true
  end
end
optparse.parse!

@yaml = YAML.load_file(@options[:yamlfile])

if @yaml.has_key?(:settings) and @yaml[:settings].is_a?(Hash)
  @yaml[:settings].each do |key,val|
    if not @options.has_key?(key)
      @options[key] = val
    end
  end
end

@defaults.each do |key,val|
  if not @options.has_key?(key)
    @options[key] = val
  end
end

def vdcupdate()
  api = ApipieBindings::API.new({:uri => @options[:uri], :username => @options[:user], :password => @options[:pass], :api_version => '2'})

  systems = []
  page = 0
  req = nil

  while (page == 0 or req['results'].length == req['per_page'].to_i)
    page += 1
    req = api.resource(:systems).call(:index, {:organization_id => @options[:org], :page => page, :per_page => 100})
    systems.concat(req['results'])
  end

  systems.each do |system|
    sys = api.resource(:systems).call(:show, {:id => system['id'], :fields => 'full'})
    puts "#{system['name']} (#{system['id']})"

    desired_sub = nil 
    remove_other = true
    @yaml[:subs].each do |sub|
      if sub.has_key?('type')
        next if sys['type'] != sub['type']
      else
        next if sys['type'] != 'Hypervisor'
      end

      if sub.has_key?('registered_by') and sub['registered_by']
        next if sub['registered_by'] != system['registered_by']
      end
      hostnameregex = Regexp.new(sub['hostname'])
      if hostnameregex.match(system['name'])
        desired_sub = sub['sub']
        if sub.has_key?('remove_other')
          remove_other = sub['remove_other']
        end
        break
      end
    end

    if desired_sub
      has_desired_sub = false
      if api.has_resource?(:host_subscriptions)
        req = api.resource(:host_subscriptions).call(:index, {:organization_id => @options[:org], :host_id => system['host_id'], :per_page => 100})
      else
        req = api.resource(:subscriptions).call(:index, {:organization_id => @options[:org], :system_id => system['id'], :per_page => 100})
      end
      req['results'].each do |sub|
        if (sub.has_key?('subscription_id') and sub['subscription_id'] == desired_sub) or (sub.has_key?('cp_id') and sub['cp_id'] == desired_sub)
          puts " found #{desired_sub}"
          has_desired_sub = true
        elsif remove_other
          puts " removing #{sub['subscription_id']}"
          if not @options[:noop]
            if api.has_resource?(:host_subscriptions)
              api.resource(:host_subscriptions).call(:remove_subscriptions, {:host_id => system['host_id'], :subscriptions => [{:id => sub['id']}]})
            else
              api.resource(:subscriptions).call(:destroy, {:system_id => system['id'], :id => sub['id']})
            end
            puts " removed"
          else
            puts " [noop] removed"
          end
        end
      end
      if not has_desired_sub
        res = api.resource(:subscriptions).call(:show, {:id => desired_sub, :organization_id => @options[:org]})
        desired_sub_id = res['id']
        puts " adding #{desired_sub} (id: #{desired_sub_id})"

        if not @options[:noop]
          if api.has_resource?(:host_subscriptions)
            api.resource(:host_subscriptions).call(:add_subscriptions, {:host_id => system['host_id'], :subscriptions => [{:id => desired_sub_id, :quantity => 1}]})
          else
            api.resource(:subscriptions).call(:create, {:system_id => system['id'], :subscriptions => [{:id => desired_sub, :quantity => 1}]})
          end
          puts " added"
        else
          puts " [noop] added"
        end
      end
    end
  end
end

vdcupdate
