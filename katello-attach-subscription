#!/usr/bin/env ruby

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA 02110-1301, USA.

# support for bundler, currently commented out
#require 'rubygems'
#require 'bundler/setup'
require 'optparse'
require 'yaml'
require 'apipie-bindings'

# requiring json and csv for virt-who and density options
require 'json'
require 'csv'

require_relative 'lib/katello_attach_subscription'

# force the output to be sent to stdout in a sync way
$stdout.sync = true

@defaults = {
  :noop                  => false,
  :uri                   => 'https://localhost/',
  :timeout               => 300,
  :user                  => 'admin',
  :pass                  => 'changeme',
  :org                   => 1,
  :usecache              => false,
  :cachefile             => 'katello-attach-subscription.cache',
  :virtwho               => false,
  :virtwhocachefile      => 'virt-who.cache',
  :emptyhypervisor       => false,
  :debug                 => false,
  :verbose               => false,
  :search                => nil,
  :density               => false,
  :densityfile           => 'cluster-state.csv',
  :guestreportfile       => 'guest-report.csv',
  :densityvalue          => 4,
  :elsdensityvalue       => 4,
  :elsosversion          => "<6",
  :subreport             => false,
  :subreportfile         => 'sub-report.csv',
  :detailedsubreportfile => 'detailed-report.csv',
  :verify_ssl            => true,
  :repeatAPI             => false,
  :maxstep               => 1,
  :sleepAPI              => false,
  :sleepTime             => 0,
  :sleepMult             => 1,
  :multisearch           => false,
  :clean_sub             => false
}

@options = {
  :yamlfile  => 'katello-attach-subscription.yaml',
}

# Parse the command line options
optparse = OptionParser.new do |opts|
  opts.banner = "Usage: #{opts.program_name} [options]"
  opts.version = "0.1"

  opts.on("-U", "--uri=URI", "URI to the Satellite") do |u|
    @options[:uri] = u
  end
  opts.on("-t", "--timeout=TIMEOUT", OptionParser::DecimalInteger, "Timeout value in seconds for any API calls. -1 means never timeout") do |t|
    @options[:timeout] = t
  end
  opts.on("-u", "--user=USER", "User to log in to Satellite") do |u|
    @options[:user] = u
  end
  opts.on("-p", "--pass=PASS", "Password to log in to Satellite") do |p|
    @options[:pass] = p
  end
  opts.on("-o", "--organization-id=ID", "ID of the Organization") do |o|
    @options[:org] = o
  end
  opts.on("-c", "--config=FILE", "configuration in YAML format") do |c|
    @options[:yamlfile] = c
  end
  opts.on("-n", "--noop", "do not actually execute anything") do
    @options[:noop] = true
  end
  opts.on("-s", "--search=SEARCH", "search for machines matching this string only") do |s|
    @options[:search] = s
  end
  opts.on("--read-from-cache", "use, if possible, cache file") do
    @options[:usecache] = true
  end
  opts.on("--cache-file=FILE", "read or write to cache file, based on --read-from-cache value") do |cf|
    @options[:cachefile] = cf
  end
  opts.on("--virt-who", "use the command virt-who --print to retrieve the cpu.cpu_socket(s)'s data of the hypervisors.") do
    @options[:virtwho] = true
  end
  opts.on("--virt-who-file=FILE", "read or write to virt-who cache file, based on --read-from-cache value and --virt-who.") do |vwf|
    @options[:virtwhocachefile] = vwf
  end
  opts.on("--empty-hypervisor", "remove all the empty hypervisor from Satellite before apply the subscription process. Not compatible with --check-density option.") do
    @options[:emptyhypervisor] = true
  end

  opts.on("--check-density", "check if all hosts in a cluster has an average number of guests >= 5 for assigning VDC Subscription. Not compatible with --empty-hypervisor option.") do
    @options[:density] = true
  end
  opts.on("--check-density-value=VALUE", "check if all hosts in a cluster has an average number of guests >= VALUE for assigning VDC Subscription. Not compatible with --empty-hypervisor option.") do |val|
    @options[:densityvalue] = val
  end
  opts.on("--check-density-file=FILE", "Write report of cluster state to custom file. Not compatible with --empty-hypervisor option.") do |crf|
    @options[:densityfile] = crf
  end

  opts.on("--print-subscription-report", "Print a report for the subscription used by of all hosts") do
    @options[:subreport] = true
  end
  opts.on("--print-subscription-report-file=FILE", "Print a report for the subscription in a custom file used by of all hosts") do |srf|
    @options[:subreportfile] = srf
  end

  opts.on("--multiple-search", "Allow to search content-hosts with the order of query result in yaml configuration file") do
    @options[:multisearch] = true
  end

  opts.on("--clean-same-product", "Ensure that all the content hosts has 1 subscriptions for every product found from yaml configuration file") do
    @options[:clean_sub] = true
  end

  opts.on("--repeat-API", "Allow to repeat API for a certain number before fail") do
  @options[:repeatAPI] = true
  end
  opts.on("--max-step=MAX_STEP", "Set the number of tentative which API try to repeat API Call in case of fails") do |step|
    @options[:maxstep] = step
  end
  opts.on("--repeat-API-sleep", "Allow to add an incremental waiting time configurable via configuration file") do
    @options[:sleepAPI] = true
  end

  opts.on("-v", "--verbose", "verbose output for the script") do
    @options[:verbose] = true
  end
  opts.on("-d", "--debug", "debug output for the script") do
    @options[:verbose] = true
    @options[:debug] = true
  end
  opts.on("--no-verify-ssl", "don't verify SSL certs") do
    @options[:verify_ssl] = false
  end
end
optparse.parse!

# load the configuration files settings
@yaml = YAML.load_file(@options[:yamlfile])

@virtwho_location = ""

# override configuration files settings with command lines one
if @yaml.has_key?(:settings) and @yaml[:settings].is_a?(Hash)
  @yaml[:settings].each do |key,val|
    if not @options.has_key?(key)
      @options[key] = val
    end
  end
end

# check if incompatible options are present
if @options[:emptyhypervisor] and @options[:density]
  puts "FATAL ERROR: Script can't run with --empty-visor and --check-density options enabled. Choose only one."
  exit 5
end

# check if virt-who is intalled and obtain location
if @options[:virtwho]
  if @options[:verbose]
    puts "--virt-who options enabled. Check if virt-who is installed"
  end
  @virtwho_location = `which virt-who`
  if not $?.exited? or $?.exitstatus.to_i != 0
    puts "FATAL ERROR: --virt-who option requested, but virt-who is not installed. re run without --virt-who or install it."
    exit 5
  end
  @virtwho_location = @virtwho_location.chop!
  if @options[:debug]
    puts " DEBUG: virt-who is installed in #{@virtwho_location}"
  end
end

# if options sleepAPI get the value of
if @options[:sleepAPI]
  if @yaml.has_key?(:sleep)
    if @yaml[:sleep].has_key?(:base)
      @options[:sleepTime] = @yaml[:sleep][:base]
    else
      if @options[:debug]
        puts " DEBUG: --sleep-API option requested, but :base value not configured in YAML file, using default value"
      end
    end
    if @yaml[:sleep].has_key?(:multiplier)
      @options[:sleepMult] = @yaml[:sleep][:multiplier]
    else
      if @options[:debug]
        puts " DEBUG: --sleep-API options requested but :multiplier value not configured in YAML file, using default value"
      end
    end
  end
end

# satellite url has to start with https or PUT will fail with http error
unless @options[:uri].start_with?('https://')
  abort "FATAL ERROR: the uri must start with https://"
end

# missing configuration parameters from file or command line are taken from the default one
@defaults.each do |key,val|
  if not @options.has_key?(key)
    @options[key] = val
  end
end

# binding api
@api = ApipieBindings::API.new({:uri => @options[:uri], :username => @options[:user], :password => @options[:pass], :api_version => '2', :timeout => @options[:timeout]}, {:verify_ssl => @options[:verify_ssl]})

# error passed trough api call
@api_error = false

# global variable of the script

# availability of virt-who data after cache parsing or virt-who --print running
@virtwho_data = false

# parsed hypervisors from virt-who cache or virt-who --print retrieved data
@parsed_hypervisors_hash = {}

# list of cluster that has density >= @options[:densityvalue]
@full_cluster  = []

# list of cluster that has density < @options[:densityvalue]
@empty_cluster = []

# list of cluster data calculated for --check-density options
@cluster_data = []

# lsit of hypervisor with cluster data attached on every hypervisor entry, used for checking density of the cluster
@clustered_hypervisor_list = []

# hash of the subscription that we need to attach to all host for getting every host fully entitled
@subs_count = {}

# array with all the guest detail for the guest/host/cluster report
@guest_list = []

# array with all the subs consumed by all the hosts
@detailed_report = []

# list of hosts id that are already passed in katello-attach-subscription
@checked_hosts = []

# INSTANCE_MULTIPLIER WORKAROUND (BZ 1664614 - https://bugzilla.redhat.com/show_bug.cgi?id=1664614)
# full explanation of the bug and workaround in the readme
# list of the sub that has instance_multiplier that had to be 2
@exception_sub = [
  "Red Hat Enterprise Linux Server, Standard (Physical or Virtual Nodes)",
  "Red Hat Enterprise Linux Server, Premium (Physical or Virtual Nodes)",
  "Smart Management",
  "Red Hat Enterprise Linux Extended Life Cycle Support (Physical or Virtual Nodes)"
]

# check functions
def checksubs()
  # initialize variables
  # by default any kind of subscription is fine
  subfiltertype = nil
  cachepresent = false
  if @options[:usecache]
    # read cached sub from cache file searching 'subs'
    puts "Reading subscription from cache."
    cachefile = "#{@options[:cachefile]}_org#{@options[:org]}"
    @yaml[:subs] = readfromcache(cachefile, 'subs')
    # if readed subs are present set cachepresent as true
    if @yaml[:subs].count > 0
      cachepresent = true
    end
  end

  # sanity check and fix of yaml file for subscription
  # going to check if any id in the yaml do not exists, and expand the search keys
  # sub will keep the originally requested subscriptions, sub_parsed the found one
  if not cachepresent
    puts "Subscription parsing started. Please be patient."
    subsyamltotalentry = @yaml[:subs].count
    @yaml[:subs].each_with_index do |sub, subcurrentcount|
      # search always for NORMAL sub as they could be attached booth hypervisor, physical and guest host
      subfiltertype = "NORMAL"
      puts " Started parsing entry #{subcurrentcount+1}/#{subsyamltotalentry}"
      # check if the hash contains data. If not, skip it.
      if not sub.is_a?(Hash)
        puts "  YAML entry without valid data, like empty entry. No further actions on this entry."
        next
      end
      # starting the process
      if @options[:verbose]
        puts " VERBOSE: started parsing for entry '#{sub["hostname"]}'"
      end
      if @options[:verbose]
        puts " VERBOSE: subs look for host type '#{sub["type"]}', looking for '#{subfiltertype}' subscriptions"
      end
      # check only the sub section
      # if sub is empty, auto-attach
      if sub.has_key?('sub')
        # initialize variables
        sub_parsed = {}
        desired_sub_hash = sub['sub']
        if not desired_sub_hash.is_a?(Hash)
          puts "  YAML entry without valid data, like empty subscription. As no valid subscriptions are listed, that will be deleted on the given hosts."
          next
        end
        # for every product (hash key in yaml) check the desired subs
        desired_sub_hash.each do |product, desidered_product_sub_array|
          parsed_product_sub_array = []
            puts "  Started parsing for product '#{product}'"
          if @options[:debug]
            puts "  DEBUG: in the desired_sub_hash, desidered_product_sub_array: #{desidered_product_sub_array}"
          end
          desidered_product_sub_array.each do |subscription_item|
            parsed_subscription = []
            if @options[:verbose]
              puts "   VERBOSE: parsing subscription '#{subscription_item}'"
            end
            # fetch all the result searching subscription by their name, stored in subscription_item
            search_options = KatelloAttachSubscription::Utils.search_args(subscription_item)
            parsed_subscription = fetch_all_results(:subscriptions,:index,{:search => search_options, :available_for => "host"})
            # if the lookup has given no results at all, no subscriptions has to be added
            if parsed_subscription.empty?
              puts "    Subscription parsing results of search string '#{subscription_item}' is empty, not adding any subscription"
              next
            end
            if @options[:debug]
              puts "  DEBUG: retrieved subscription"
              p parsed_subscription
            end
            # if empty, so zero results, this will be simply skipped
            parsed_subscription.each do |subscription|
              if @options[:debug]
                puts "   DEBUG: subscription detail for subscription #{subscription['cp_id']}:"
                p subscription
              end
              # The type is defined in yaml. Currently handling only the Hypervisor subs, derivated one should be not considered for hypervisors.
              if subfiltertype and subscription.has_key?('type') and subscription['type'] != subfiltertype
                if @options[:debug]
                  puts "   Skipping '#{subscription['cp_id']}' as system type '#{subscription['type']}' is different from desired '#{subfiltertype}'"
                end
                # if the filter do not match, skip to next subscription
                next
              end
              parsed_product_sub_array.push(subscription['cp_id'])
            end
            puts "    Subscription parsing results of search string '#{subscription_item}' is #{parsed_product_sub_array}"
            # push new subs to array with new key for this product
            sub_parsed[product] = parsed_product_sub_array
            # and copy to the pointer for this product
            # sub['sub'] are the requested subs
            # sub['sub_parsed'] are the subs found that has to be associated
            sub['sub_parsed']=sub_parsed
          end
        end
      end
    end
    if @options[:debug]
      puts " DEBUG: the full yaml subs output after modification"
      p @yaml[:subs]
    end
  end

  # if virt-who option is enabled we are going to execute the command virt-who --print to retrieve
  # hypervisors data and so their number of socket
  json_hash = {}
  run_virtwho_print = false

  if @options[:debug]
    puts "DEBUG: virt-who enabled: #{@options[:virtwho]}"
  end

  if @options[:virtwho]
    # virt-who cachefile contain the cached data of the json with the hypervisor data
    # the desired pattern for the name of this cache file is virt-who-{ date in yyyymm }.cache_org{ organization id }
    virtwho_cachefile = @options[:virtwhocachefile].to_s + "_org" + @options[:org].to_s
    # assuming that no cache is present
    run_virtwho_print = true
    # :usecache options is enabled, before launch virt-who --print, try to read the cache file
    if @options[:usecache]
      run_virtwho_print = false
      # read virt-who cache calling readfromcache function
      cachefile = "#{@options[:virtwhocachefile]}_org#{@options[:org]}"
      json_hash = readfromcache(cachefile, '')
      if @options[:debug]
        puts "DEBUG: raw virt-who.cache parsed data"
        p json_hash
      end
      # check if the json_hash contains valid data by calling validhypervisordata functions
      if KatelloAttachSubscription::VirtWhoHelper.validhypervisordata(json_hash)
        # check the sanity of every hypervisor, searching if the data we need are present
        puts "Starting virt-who cache file parsing. Please be patient."
        @parsed_hypervisors_hash = KatelloAttachSubscription::VirtWhoHelper.cleanhypervisorfromrawvirtwho(json_hash)
        # if parsed_hypervisors_hash isn't empty then virt-who --print should not run
        if not @parsed_hypervisors_hash.empty?
          run_virtwho_print = false
          @virtwho_data = true
        else
          # if parsed_hypervisors_hash is empty then try to run virt-who --print to retrieve data
          puts " Hypervisor parsing results from cache is empty, 'virt-who --print' will run to retrieve data"
          run_virtwho_print = true
        end
      else
        # if returned value is false then run virt-who --print to retrieve data
        puts "Invalid or empty JSON of virt-who cache file, 'virt-who --print' will run to retrieve data"
        run_virtwho_print = true
      end
    end
    # if run_virtwho_print is true then run virt-who --print
    if run_virtwho_print
      puts "Running the command '#{@virtwho_location} --print' to retrieve Hypervisors data. Please be patient."

      # run virt-who --print and send debug output to /dev/null as it's not useful for the script
      virtwho_print_output = `#{@virtwho_location} --print 2>> /dev/null`
      # if extited correctly start to parse the output
      if $?.exited? and $?.exitstatus == 0
        virtwho_print_output = virtwho_print_output.chop!
        if @options[:debug]
          puts "  DEBUG: virt-who --print output: "
          p virtwho_print_output
        end
        puts "Command 'virt-who --print' command run successfully. Starting to parse Hypervisors data. Please be patient."
        # start parsing virt-who --print output
        json_hash = JSON.parse(virtwho_print_output)
        # if raw data of json is valid then start checking retrieved data
        if KatelloAttachSubscription::VirtWhoHelper.validhypervisordata(json_hash)
          # clean raw json_hash from entry without socket and cluster data and store the new hash in @parsed_hypervisors_hash
          @parsed_hypervisors_hash = KatelloAttachSubscription::VirtWhoHelper.cleanhypervisorfromrawvirtwho(json_hash)
          # if parsed_hypervisors_hash isn't empty, set virtwho_data to true so this data can use for rescue socket or cluster data in case satellite API fails to retrieve facts from Satellite
          if not @parsed_hypervisors_hash.empty?
            @virtwho_data = true
          else
            # if parsed hypervisor is empty then no data would be used to recover satellite facts fails
            puts " Hypervisor parsing results from 'virt-who --print' is empty, no data from virt-who would be used."
            @virtwho_data = false
          end
        else
          puts "Invalid or empty JSON parsed from virt-who. virt-who data would be ignored."
          @virtwho_data = false
        end
      else
        puts "FATAL ERROR: something went wrong while running virt-who --print command. Possible fix it's to avoid running virt-who as service"
        exit 5
      end

    end
    if @options[:debug]
      puts " DEBUG: the full hypervisor data from JSON output after using virt-who option is:"
      p @parsed_hypervisors_hash
    end
    if not @options[:usecache]
      # always write the cache file at the end, to be used in the future
      puts "Writing JSON file into cache file #{virtwho_cachefile}"
      json_cache_file = File.open(virtwho_cachefile,"w") do |f|
        f.write(JSON.pretty_generate(json_hash))
      end
    end
  end

  # starting retrieve hypervisor data from Satellite API
  # searching if empty-hypervisor or cluster density options
  hypervisors_collection = []
  if @options[:emptyhypervisor] or @options[:density]
    puts "Starting retrieving hypervisor data. Please be patient."
    hypervisors_list = []
    # fetch all the result searching hosts using 'hypervisor=true' as filter
    hypervisors_list = fetch_all_results(:hosts, :index, {:search => "hypervisor=true"})
    if @options[:verbose]
      puts "  VERBOSE: Start retrieving full data for every hypervisors."
    end
    # loop all retrieved hypervisor
    hypervisors_list.each_with_index do |system, currentcount|
      if @options[:verbose]
        puts "    VERBOSE: Current hypervisor #{currentcount+1}/#{hypervisors_list.count}: #{system['name']} (#{system['id']})"
      end
      # retrieve full data for every hypervisor found
      sys = apiCall(:hosts, :show, { :id => system['id'], :fields => 'full' }, false)
      if @api_error
        STDERR.puts "  ERROR: Hypervisor '#{system['name']}' not found. Skipping"
        next
      end
      if @options[:virtwho] and @virtwho_data
        if @options[:verbose]
          puts "VERBOSE: adding virt-who data to #{sys['name']}"
        end
        sys = KatelloAttachSubscription::VirtWhoHelper.merge_system_virtwho(sys, @parsed_hypervisors_hash, @options[:org])
      end
      hypervisors_collection.push(sys)
    end
    puts "Collecting hypervisor data completed successfully"
    if @options[:debug]
      puts "DEBUG: Hypervisor collected: "
      p hypervisors_collection
    end
  end

  # start checking 'density' of cluster
  if @options[:density]
    puts "Starting checking cluster density"
    if @options[:debug]
      if @options[:virtwho]
        puts "  DEBUG: use of virt-who enabled, if Satellite fails use its data"
      end
    end
    # sanity check, if hypervisor::cluster is not found in facts dictionary add it by searching in virt-who data
    # hypervisor::cluster guessed as possible name as cpu.cpu_socket(s) from virt-who is encoded cpu::cpu_socket(s) in Satellite Facts API
    if @options[:verbose]
      puts "  VERBOSE: Start sanity check of hypervisors data"
    end
    # initialize cluster hash dictionary for storing all cluster density data
    cluster_hash = {}
    # loop all the hypervisor founded in API call
    hypervisors_collection.each_with_index do |system, currentcount|
      if @options[:verbose]
        puts "    VERBOSE: Checking cluster of #{system['name']} #{currentcount+1}/#{hypervisors_collection.count}"
      end
      # if field hypervisor::cluster is present and setted skip recovery phase
      if system.has_key?('facts') and system['facts'].is_a?(Hash) and system['facts'].has_key?('hypervisor::cluster') and system['facts']['hypervisor::cluster']
        if @options[:debug]
          puts "      DEBUG: Hypervisor cluster of #{system['name']} is #{system['facts']['hypervisor::cluster']}"
        end
      else
        if @options[:verbose]
          puts "      VERBOSE: No Hypervisor cluster data found in Satellite for #{system['name']}. Marking with 'nil' as default"
        end
        # saving cluster name as nil
        system.merge!({"facts"=>{'hypervisor::cluster'=>'nil'}})
      end
      # save in the hypervisor data with cluster saved
      @clustered_hypervisor_list.push(system)
    end
    if @options[:debug]
      puts "  DEBUG: Full clustered hypervisor data"
      p @clustered_hypervisor_list
    end
    # start counting guest and hosts for every cluster
    if @options[:verbose]
      puts "  VERBOSE: Complete retrieving cluster data of all Hypervisor. Starting counting Hosts and Guests."
    end
    ccluster_hash = {}
    # loop all the clustered hypervisor
    @clustered_hypervisor_list.each_with_index do |clu_hypervisor, index|
      hname = clu_hypervisor['facts']['hypervisor::cluster']
      hsocket = 1
      if clu_hypervisor['facts'].has_key?('cpu::cpu_socket(s)')
        hsocket = clu_hypervisor['facts']['cpu::cpu_socket(s)'].to_i
      end
      # if no cluster are already present in ccluster dict, with all the data, create the new entry
      if not ccluster_hash.has_key?(hname)
        ccluster_hash[hname] = {'hosts' => 0, 'guests' => 0, 'socket' => 0, 'els_guests' => 0}
      end
      # set the value of hosts and guests found in hypervisor entry
      ccluster_hash[hname]['hosts'] += 1
      ccluster_hash[hname]['guests'] += clu_hypervisor['subscription_facet_attributes']['virtual_guests'].count
      ccluster_hash[hname]['socket'] += hsocket
      # getting guests data of the hypervisor searching for els
      search_options = "hypervisor_host=virt-who-#{clu_hypervisor['name']}-#{@options[:org]} and organization_id=#{@options[:org]}"
      guests_lists = fetch_all_results(:hosts, :index, {:search => search_options})
      # looping to check which guests need ELS
      guests_lists.each do |single_guest|
        single_guest_os = single_guest['operatingsystem_name'].gsub(/[^\d.]/,'')
        if KatelloAttachSubscription::HostMatcher.match_version(@options[:elsosversion], single_guest_os)
          ccluster_hash[hname]['els_guests'] += 1
        end
      end
      # append guest of hypervisor to guest report, passing clu_hypervisor as guests are present in subscription_facet_attributes dict
      collectguestdata(clu_hypervisor, guests_lists)
    end

    # 'print' in the csv file the guest report
    printguestreport()

    if @options[:debug]
      puts "All cluster hosts / guests count data:"
      p ccluster_hash
    end
    # set variable to save for every cluster:
    # index, name, number of hosts and number of guests
    total_hosts_ok = 0
    total_hosts_bad = 0
    total_guests_ok = 0
    total_guests_bad = 0
    total_cluster_ok = 0
    total_cluster_bad = 0
    dict_index = 0
    # list of all csv data to write in the file
    csvcluster = []
    # loop all the counted cluster
    ccluster_hash.each do |key, dict|
      # key is the name of the cluster
      dict_name = key
      # dict the hash with all the data about it as number of hosts and guests
      dict_hosts = dict['hosts']
      dict_guests = dict['guests']
      dict_socket = dict['socket']
      dict_els_guests = dict['els_guests']

      # divide guests by number of sockets hists divided by 2
      dict_ratio = dict_guests.to_f / (dict_socket.to_f / 2)
      # round to the first 2 decimal digit
      dict_ratio = dict_ratio.round(2)

      # divide guests by number of sockets hists divided by 2
      dict_els_ratio = dict_els_guests.to_f / (dict_socket.to_f / 2)
      # round to the first 2 decimal digit
      dict_els_ratio = dict_els_ratio.round(2)

      @cluster_data.push({"cluster_name" => dict_name, "cluster_socket" => dict_socket, "cluster_hosts" => dict_hosts, "cluster_guests" => dict_guests, "cluster_ratio" => dict_ratio, "cluster_els_guests" => dict_els_guests, "cluster_els_ratio" => dict_els_ratio})
      dict_state = ""
      # if ratio is >= densityvalue (default 5) add cluster to the high density ones which has to be subscribed with VDC
      if dict_ratio >= @options[:densityvalue].to_f
        dict_state = 'OK'
        # add to the global count of hosts and guests that are in high density cluster
        total_hosts_ok += dict_hosts
        total_guests_ok += dict_guests
        total_cluster_ok += 1
        # add the cluster name in full_cluster that represent the list of high density cluster
        if dict_name != 'nil' and dict_name != 'none'
          @full_cluster.push(dict_name)
        end
      else
        # else if it's lower mark status as ERROR (light density) and remove vdc subscription to this cluster
        dict_state = 'ERROR'
        if dict_ratio == 0
          dict_state = 'OK'
        end
        # add to the global count of hosts and guests that are in light density cluster
        total_hosts_bad += dict_hosts
        total_guests_bad += dict_guests
        total_cluster_bad += 1
        # add the cluster name in empty_cluster that represent the list of light density cluster
        if dict_name != 'nil' and dict_name != 'none'
          @empty_cluster.push(dict_name)
        end
      end
      # add all the processed variables to cluster row for the CSV file
      cluster_row = {}
      cluster_row['index'] = dict_index
      cluster_row['name'] = dict_name
      cluster_row['socket'] = dict_socket
      cluster_row['hosts'] = dict_hosts
      cluster_row['guests'] = dict_guests
      cluster_row['ratio'] = dict_ratio
      cluster_row['els_guests'] = dict_els_guests
      cluster_row['els_ratio'] = dict_els_ratio
      cluster_row['state'] = dict_state
      csvcluster.push(cluster_row)
      dict_index += 1
    end

    if @options[:verbose]
      puts "  VERBOSE: Retrieve cluster data successfully"
    end
    if @options[:debug]
      p csvcluster
    end
    if @options[:verbose]
      puts "  VERBOSE: Start write file #{@options[:densityfile]} with cluster density"
    end
    # write the CSV data in :densityfile, data separated with ; to avoid mismatch with , or . for decimal value
    CSV.open(@options[:densityfile], "wb", {:col_sep => ";"}) do |csv|
      # header of csv
      csv << ["Index","Cluster Name","Total Socekt","Hosts","Guests","Ratio","State","ELS Guests","ELS Ratio"]
      # print for last the host without cluster (none) or no rescue data in it (nil)
      none_index = -1
      nil_index = -1
      # first search for it and save it in none_index and nil_index
      csvcluster.each do |cluster_row|
        if cluster_row['name'] == 'none'
          none_index = cluster_row['index'].to_i
          next
        end
        if cluster_row['name'] == 'nil'
          nil_index = cluster_row['index'].to_i
          next
        end
        # if current cluster isn't nil or none write in the csv file
        csv << [cluster_row['index'],cluster_row['name'],cluster_row['socket'],cluster_row['hosts'],cluster_row['guests'],cluster_row['ratio'],cluster_row['state'],cluster_row['els_guests'],cluster_row['els_ratio']]
      end
      # if none cluster are present report it
      if none_index > -1
        none_cluster = (csvcluster.select {|clstr| clstr['name'] == 'none'}).first
        # none cluster => cluster data not found in Satellite and 'virt-who --print' hypervisor entry found but no cluster data present
        none_string = "NONE: cluster data not found in Satellite and 'virt-who --print' hypervisor entry found but no cluster data present"
        csv << [none_cluster['index'],none_string,none_cluster['socket'],none_cluster['hosts'],none_cluster['guests'],none_cluster['ratio'],none_cluster['state'],none_cluster['els_guests'],none_cluster['els_ratio']]
      end
      # if nil cluster are present report it
      if nil_index > -1
        nil_cluster = (csvcluster.select {|clstr| clstr['name'] == 'nil'}).first
        # nil cluster => cluster data not found in Satellite or/and 'virt-who --print' hypervisor entry not found
        nil_string = "NIL: cluster data not found in Satellite or/and 'virt-who --print' hypervisor entry not found"
        csv << [nil_cluster['index'],nil_string,nil_cluster['socket'],nil_cluster['hosts'],nil_cluster['guests'],nil_cluster['ratio'],nil_cluster['state'],nil_cluster['els_guests'],nil_cluster['els_ratio']]
      end
      # add also a global count of OK and ERROR cluster with their count
      csv << [""]
      csv << [""]
      csv << ["","","Total", "OK Cluster", total_cluster_ok, "OK Hosts", total_hosts_ok, "OK Guests", total_guests_ok]
      csv << ["","","Total", "ERR Cluster", total_cluster_bad, "ERR Hosts", total_hosts_bad,"ERR Guests", total_guests_bad]
    end

    puts "Density check of cluster completed. Saved in #{@options[:densityfile]}"
    @empty_cluster.push('nil')
    @empty_cluster.push('none')
    if @options[:debug]
      puts "\n  DEBUG: List of cluster with full hypervisor"
      p @full_cluster
      puts "  DEBUG: List of cluster with empty hypervisor"
      p @empty_cluster
    end
  end

  # before attaching subscription to hosts, check if empty hypervisors with valid subscription are present
  # if they are present remove their subscriptions to free subscription "slot"
  if @options[:emptyhypervisor]
    puts "Starting empty hypervisor subscription removal."
    # if are present hypervisors to be removed then start checking their state
    if not hypervisors_collection.empty?
      # get the total number of hypervisors
      remove_total = hypervisors_collection.count
      if @options[:verbose]
        puts "  VERBOSE: Found #{remove_total} hypervisors."
      end
      puts "Start checking if empty hypervisor are present to remove."
      hypervisors_collection.each_with_index do |system, currentcount|
        if @options[:verbose]
          puts " VERBOSE: Current founded hypervisor #{currentcount+1}/#{remove_total}: #{system['name']} (#{system['id']})"
        end
        # check if almost 1 virtual_guest is present on subscription_facet_attributes
        # if system["subscription_facet_attributes"]["virtual_guests"].count > 0
        if hypervisor_has_guests(system)
          # if present skip, we must remove subscritions only from empty hypervisor
          if @options[:verbose]
            puts "   VERBOSE: Skipping #{system["name"]} as virtual guest count is #{system["subscription_facet_attributes"]["virtual_guests"].count}"
          end
          next
        end
        # if no guests present, retrieve all subscription data from that hypervisor
        rem_sub_response = apiCall(:host_subscriptions, :index, {:host_id => system['id']}, false)
        if @api_error
          STDERR.puts "   ERROR: Hypervisor #{system['name']} subscription data not found. Skipping."
          next
        end
        # check if data found (API return data successfully)
        if not rem_sub_response.has_key?("total")
          if @options[:verbose]
            puts "    VERBOSE: Skipping Hypervisor as not valid data was retrieved from API"
          end
          next
        end
        # check if total > 0, then loop the result to remove the subscriptions
        if rem_sub_response["total"].to_i > 0
          puts "    Starting removing subscriptions from Hypervisor"
          rem_sub_response["results"].each_with_index do |rem_sub, currentsub|
            if @options[:verbose]
              puts "      VERBOSE: Removing subscription #{currentsub+1} / #{rem_sub_response["total"].to_i} - #{rem_sub['id']}"
            end
            if @options[:debug]
              puts "      DEBUG: Current subscription data"
              p rem_sub
            end
            if not @options[:noop]
              apiCall(:host_subscriptions, :remove_subscriptions, {:host_id => system['id'], :subscriptions => [{:id => rem_sub['id']}]}, false )
              if @api_error
                puts "      Can't remove subscription #{rem_sub['id']} from hypervisor #{system['name']} / #{system['id']}. Skipping"
                next
              end
              puts "      Removed subscription #{rem_sub['id']} from hypervisor #{system['name']} / #{system['id']}"
            else
              puts "      [noop]: sub #{rem_sub['id']} would be removed from hypervisor #{system['name']} / #{system['id']}"
            end
          end
        else
          puts "    No subscription found attached to #{system['name']}. Nothing to do."
        end
      end
    else
      if @options[:verbose]
        puts "  VERBOSE: No empty hypervisor with valid subscription found."
      end
    end
  end
end

# main function
def subsupdate()
  # initialize variables
  @default_type = nil
  @subs_count = {}
  @detailed_report = []
  systems = []
  hosts_data = []
  hosts_details_data = {}
  # Fill systems array from API of satellite. Check for cache usage.
  systems = fetch_all_systems

  puts "Starting host subscription assignment"
  systemstotal = systems.count

  # cycle for each system found
  systems.each_with_index do |system, currentcount|
    if @options[:verbose]
      puts " VERBOSE: Current system #{currentcount+1}/#{systemstotal}: #{system['name']} (#{system['id']})"
    end
    if @checked_hosts.count(system['id']) > 0
      if @options[:verbose]
        puts "   VERBOSE: host #{system['name']} is already checked. Skip to next host"
      end
      next
    end
    assignsubs(system)
  end

  # writing report of consumed subs after attaching all subs to the system
  if @options[:subreport]
    puts "Writing report of counted subs"
    printsubsreport
  end

  puts "Subscription attaching process ended."
  if not @options[:usecache]
    # always write the cache file at the end, to be used in the future
    puts "Writing YAML file into cache file #{cachefile}"
    File.open(cachefile, 'w') {|f| f.write(YAML.dump({'systems' => systems, 'subs' => @yaml[:subs]})) }
  end
end

def assignsubs(system)
  # initialize variable
  req = nil
  has_desired_sub = nil
  desired_sub = nil
  desired_sub_hash = nil
  desired_type = @default_type
  remove_other = true
  remove_subs = []
  keep_subs = []
  auto_attach = false
  keep_virt_only = false
  virtual_host = nil
  desired_quantity = 1
  sys_socket = 1
  hypervisor_found = false
  system_type = ""
  this_system_cluster = ""

  skip_host = false
  has_derived_sub = false

  subs = {}
  sys = nil
  skip_report = false
  sub_counted = []

  # add to array system the name of the system itself taken from id
  if @options[:verbose]
   puts " VERBOSE: Start assigning subscriptions to #{system['name']}"
  end
  @checked_hosts.push(system['id'])

  # get detail for the current system to be checked.
  if @options[:debug]
    puts " DEBUG: detail of the current system to be checked:"
    p system
  end

  sys = apiCall(:hosts, :show, {:id => system['id'].to_i, :fields => 'full'}, false)
  if @api_error
    STDERR.puts "   ERROR: Host #{system['name']} full api data not found. Skipping."
    return
  end

  if sys.count <= 0
    puts "  WARNING: System name '#{system['name']}' not found. Is cache in use? Skipping."
    return
  end
  # if host isn't registered by subscription manager for anyone reason, skip
  if not sys.has_key?('subscription_facet_attributes')
    if @options[:verbose]
      puts "  VERBOSE: Skipping #{sys['name']} as it isn't registered with subscription manager"
    end
    return
  end
  if @options[:virtwho] and @virtwho_data
    if @options[:verbose]
      puts "VERBOSE: adding virt-who data to #{sys['name']}"
    end
    add_cluster_data(sys)
  end
  if @options[:debug]
    puts "  DEBUG: '#{system['name']}' id #{system['id']} :hosts api data:"
    p sys
  end
  # check if the type requested match the host one
  system_type = KatelloAttachSubscription::FactAnalyzer.system_type(sys)
  # for each item in yaml extract sub
  if @options[:debug]
    puts " DEBUG: YAML dump with all definitions for the current system"
    p @yaml
  end
  @yaml[:subs].each do |sub|
    # if "type" has been specified on yaml file check if match.
    # the default is to check on "Hypervisor"
    # if DO NOT match, skip to next sub
    # fixme: can't find this detail in new API
    if sub.has_key?('type')
      unless KatelloAttachSubscription::HostMatcher.match_type(sub['type'], system_type)
        if @options[:verbose]
          puts "  VERBOSE: Skipping '#{system['name']}' as system type '#{system_type}' is different from desired '#{sub['type']}'"
        end
        next
      end
    end

    skip_sub = true
    # extract the (possible) virtual_host
    if sub.has_key?('virtual_host')
      virtualhostregex = Regexp.new(sub['virtual_host'])
    else
      virtualhostregex = nil
    end
    # test all the facts
    if @options[:verbose]
      puts "VERBOSE: Start testing facts value for #{sys['name']}"
    end
    fact_test_passed = KatelloAttachSubscription::HostMatcher.match_host(sys, sub)
    unless fact_test_passed
      if @options[:verbose]
        puts "  VERBOSE: Host #{sys['name']} doesn't pass facts test. Skip to the next sub entry."
      end
      next
    else
      if @options[:verbose]
        puts "  VERBOSE: Host #{sys['name']} pass fact test. Proceed to attach sub."
      end
    end

    use_derived = false
    # get the value of use_derived from the yaml sub entry, if setted
    if sub.has_key?('use_derived')
      use_derived = sub['use_derived']
      if @options[:debug]
        if use_derived
          puts "  DEBUG: use_derived set to #{use_derived}"
        end
      end
    end

    if @options[:emptyhypervisor] and system_type == KatelloAttachSubscription::FactAnalyzer::HYPERVISOR
      skip_host ||= !hypervisor_has_guests(sys)
    end

    derived_sub = {}
    attachable_subs = []
    # if system is a guest and density option is on, check if use_derived is true
    if system_type == KatelloAttachSubscription::FactAnalyzer::GUEST and @options[:density] and use_derived
      # if so, fetch the stack-derived sub available for that host and replace the one in sub_parsing
      if @options[:verbose]
        puts "   VERBOSE: System #{system['name']} is a Guest and desire stack-derived sub, search for it"
      end
      subfiltertype = "STACK_DERIVED"
      attached_sub_response = apiCall(:host_subscriptions, :index, {:organization_id => @options[:org], :host_id => system['id']}, false)
      if @api_error
        puts "   ERROR: Unable to retrieve subscription data for host #{system['id']} #{system['name']}. Skipping to next host"
        next
      end
      attached_sub_response['results'].each do |attached_sub|
        if attached_sub['type'] == subfiltertype
          if @options[:debug]
            puts "    DEBUG: Sub #{attached_sub['cp_id']} is #{subfiltertype}"
          end
          has_derived_sub = true
        end
      end
      begin
        attachable_subs = fetch_all_results(:subscriptions,:index,{:available_for => "host", :host_id => system['id']})
      rescue Exception => e
        STDERR.puts "WARNING: Can't fetch available subscription for host #{system['name']} (#{system['id']}). Check on Satellite"
        STDERR.puts e
        break
      end
      # if the lookup has given no results at all, no subscriptions has to be added
      if attachable_subs.empty?
        puts "    Subscription parsing results of search string '#{subscription_item}' is empty, not adding any subscription"
        next
      end
      if @options[:debug]
        puts "  DEBUG: retrieved subscription"
        p attachable_subs
      end
      # if empty, so zero results, this will be simply skipped
      attachable_subs.each do |single_sub|
        if @options[:debug]
          puts "   DEBUG: subscription detail for subscription #{single_sub['cp_id']}:"
          p single_sub
        end
        # check if sub isn't stack_derived
        if single_sub['type'] != subfiltertype
          if @options[:debug]
            puts "   Skipping '#{single_sub['cp_id']}' as system type '#{single_sub['type']}' is different from desired '#{subfiltertype}'"
          end
          # if the filter do not match, skip to next subscription
          next
        end
        # create product_id key in the derived_sub dictionary if product_id is not yet present in it
        if not derived_sub.has_key?(single_sub['product_id'])
          derived_sub[single_sub['product_id']] = []
        end
        derived_sub[single_sub['product_id']].push(single_sub['cp_id'])
      end
      if @options[:debug]
        puts "      DEBUG: Subscription to attach at guest #{system['name']}"
        p derived_sub
      end
      if derived_sub.empty?
        if @options[:verbose]
          puts "     VERBOSE: No sub available to be attached for #{system['name']}"
        end
      else
        # set change sub to true will attach the derivated one from
        has_derived_sub = true
      end
    end

    # starting to get the correct number of socket to calculate the correct number of subscription to attach
    if @options[:debug]
      puts " DEBUG: Checking the number of socket for #{sys["name"]}"
    end
    # if the number of socket is setted, we can find the value from cpu::cpu_socket(s)
    if sys.has_key?("facts") and sys["facts"].is_a?(Hash) and sys["facts"].has_key?("cpu::cpu_socket(s)")
      # if the field is present check if it's a valid entry or not, if not exit with error
      if sys["facts"]["cpu::cpu_socket(s)"].to_i > 0
        # set sys_socket to the value of cpu::cpu_socket(s)
        sys_socket = sys["facts"]["cpu::cpu_socket(s)"].to_i
        if @options[:debug]
          puts "   DEBUG: Setting sys_socket to #{sys_socket} for #{sys["name"]}"
        end
      else
        puts "   FATAL ERROR: The number of socket for #{sys["name"]} it's equal or lower then 0."
        exit 5
      end
    else
      sys_socket = 1
      if @options[:debug]
        puts "   DEBUG: No cpu sockets entry found for #{sys['name']}, assigned 1 by default"
      end
    end

    if @options[:debug]
      puts " DEBUG: System '#{system['name']}' in scope, proceeding with assignment of variables"
    end
    # set the desidered subscription to be associated
    sub_layer = sub['sub_layer'] || "stop_parsing"
    if @options[:debug]
      puts " DEBUG: Sub Layer of this sub entry: #{sub_layer}"
    end
    if sub.has_key?('sub_parsed')
      if has_derived_sub
        desired_sub_hash = KatelloAttachSubscription::Utils.merge_subs(desired_sub_hash, derived_sub, sub_layer)
      else
        desired_sub_hash = KatelloAttachSubscription::Utils.merge_subs(desired_sub_hash, sub['sub_parsed'], sub_layer)
      end
    end
    # if "remove_other" has been set, set the flag
    if sub.has_key?('remove_other')
      remove_other = sub['remove_other']
    end
    # if "remove_subs" has been set, use it
    if sub.has_key?('remove_subs')
      remove_subs = sub['remove_subs']
    end
    # if "keep_subs" has been set, use it
    if sub.has_key?('keep_subs')
      keep_subs = sub['keep_subs']
    end
    # if "auto_attach" has been set, set the flag
    if sub.has_key?('auto_attach')
      auto_attach = sub['auto_attach']
    end
    # if "keep_virt_only" has been set, set the flag
    if sub.has_key?('keep_virt_only')
      keep_virt_only = sub['keep_virt_only']
    end

    # if the system is found and sub_layer is "stop_parsing", stop cyclyng over yaml
    if sub_layer == "stop_parsing"
      break
    end

  end
  if skip_host
    if @options[:verbose]
      puts " VERBOSE: Skipping #{system['name']} as host doesn't need nothing more to do."
    end
    return
  end
  # check if one or more hosts need a subscription
  if @options[:debug]
    puts " DEBUG: desired_sub_hash value"
    p desired_sub_hash
  end

  if desired_sub_hash or not remove_subs.empty?
    # maybe we do not have any subs to add, but remove_subs was not empty
    if not desired_sub_hash
      desired_sub_hash = {'none' => []}
    end

    if @options[:clean_sub]
      cleanable_sub = apiCall(:host_subscriptions, :index, {:organization_id => @options[:org], :host_id => system['id'], :per_page => 100}, false )
      clean_same_product(desired_sub_hash, cleanable_sub["results"], system, system_type, sys_socket)
    end

    if @options[:debug]
      puts " DEBUG: Checking subscription for #{system['name']} (#{system['id']})"
    end
    has_desired_sub_hash = {}
    # for every product (hash key in yaml) check the desired subs
    desired_sub_hash.each do |product, desidered_product_sub_array|
      if @options[:debug]
        puts "   DEBUG: in the desired_sub_hash #{desidered_product_sub_array}"
      end
      has_desired_sub = false
      # check the current associated subscription to this system
      req = apiCall(:host_subscriptions, :index, {:organization_id => @options[:org], :host_id => system['id'], :per_page => 100}, false )
      if @api_error
        STDERR.puts "  WARNING: Subscription problem -- unable to retrieve subscription for host #{system['id']} #{system['name']}"
        next
      end
      # check a single subscription in the array
      req['results'].each do |sub|
        # check if the found cp_id is in the list of the current product, if it is, our job here is done
        if desidered_product_sub_array.include?(sub['cp_id'])
          total_subscriptions = KatelloAttachSubscription::Utils.needed_entitlement(system_type, sys_socket, sub)
          puts "  #{system['name']} need #{total_subscriptions} subscriptions for sub #{sub['id']}"
          subscriptions_needed = total_subscriptions - sub['quantity_consumed'].to_i

          if @options[:subreport] and not has_derived_sub
            # count the sub to add, if not just present
            if @options[:debug]
              puts "      DEBUG: Current counted sub: #{sub_counted}"
            end
            # if not present, call addtototalsubneeded to add the count of subs
            if not sub_counted.include?(sub['name'])
              skip_report = true
              addtototalsubneeded(system['name'], sub['name'], total_subscriptions)
              # add to the subs counted
              sub_counted.push(sub['name'])
            else
              # if just counted don't do nothing
              if @options[:debug]
                puts "      DEBUG: Skipping count as sub #{sub['name']} is just present"
              end
            end
          end
          if not has_derived_sub
            # check sub needed = 0
            if subscriptions_needed == 0
              puts "  subscription #{sub['cp_id']} for #{product} product is already attached to #{system['name']}"
            else
              # if subscriptions_needed != 0 then attached sub to the host consumed_quantity is < or > of the correct one.
              if subscriptions_needed < 0
                puts "  WARNING: Subscription #{sub['id']} attached #{sub['quantity_consumed']} that is > of quantity needed: #{total_subscriptions}, sub would be removed and reattached"
              else
                puts "  subscription #{sub['cp_id']} for #{product} product is attached to #{system['name']}, but still need to consume #{subscriptions_needed} token, sub would be removed and reattached"
              end
              # check if sub available sub are >= of the one needed as
              # - if sub_needed > 0 then we need to see if (qty attached + qty to attach) < qty available
              if sub['available'] >= subscriptions_needed
                # set subscriptions_needed to the total ones as current sub is to be removed and reattached consuming total_subscriptions sub.
                subscriptions_needed = total_subscriptions
                if not @options[:noop]
                  puts "  removed #{sub['id']} - #{sub['cp_id']}"
                  apiCall(:host_subscriptions, :remove_subscriptions, {:host_id => system['id'], :subscriptions => [{:id => sub['id']}]}, false)
                  if @api_error
                    STDERR.puts "WARNING: Unable to remove subscription #{sub['id']} from #{system['name']} - ID: #{system['id']}"
                  end
                  puts "  reattached #{sub['id']} - #{sub['cp_id']}"
                  apiCall(:host_subscriptions, :add_subscriptions, {:host_id => system['id'], :subscriptions => [{:id => sub['id'], :quantity => subscriptions_needed}]}, false)
                  if @api_error
                    STDERR.puts "WARNING: Unable to attach subscription #{sub['id']} to #{system['name']} - ID: #{system['id']}"
                  end
                else
                  puts "  [noop]: #{sub['id']} - #{sub['cp_id']} would be removed and reattached with correct quantity: #{subscriptions_needed}"
                end
              else
                puts " Skipping fixing the subscription of #{sub['id']} for #{system['name']} because #{subscriptions_needed} requested but #{sub['available']} available"
              end
            end
          end
          has_desired_sub = true
        # else, if this is not among the desired subscriptions (ALL of them, not only the current product)
        # and remove_other is set, remove this subscription to the system
        elsif sub['cp_id'] != nil and not desired_sub_hash.flatten(2).include?(sub['cp_id']) and (remove_other or remove_subs.include?(sub['cp_id'])) and not (keep_virt_only and sub.has_key?('virt_only') and sub['virt_only']) and not keep_subs.include?(sub['cp_id'])
          puts "  removing subscription #{sub['cp_id']} from system #{system['name']}"
          if not @options[:noop]
            apiCall(:host_subscriptions, :remove_subscriptions, {:host_id => system['id'], :subscriptions => [{:id => sub['id']}]}, false)
            if @api_error
              STERR.puts "WARNING: Unable to remove subscription #{sub['id']} from #{system['name']} - ID: #{system['id']}"
            else
              puts "  removed"
            end
          else
            puts "  [noop] removed"
          end
        end
      end
      # if all of the subscriptions marked for this product is missing, mark it to be added
      if not desidered_product_sub_array.empty? and not has_desired_sub
        puts "  Subscription on host #{system['name']} for product " + product.to_s + " currently missing. Set for the attach."
        has_desired_sub_hash[product] = desidered_product_sub_array
      end
    end

    if @options[:debug]
      puts "  DEBUG: has_desired_sub_hash: #{has_desired_sub_hash}"
    end

    # if the system do not has proper subscritions, attach it
    if has_desired_sub_hash
      # cycle for each product
      has_desired_sub_hash.each do |product, desired_subs_hash|
        sub_attached = false
        # cycle for each subscription
        desired_subs_hash.each do |desired_sub|
          if @options[:debug]
            puts "  DEBUG: current subscription to be checked"
            p desired_sub
          end
          # if subs[desired_sub] is false, retrieve the current subscription detail
          subs[desired_sub] ||= apiCall(:subscriptions, :index, {:search => "id=#{desired_sub}", :organization_id => @options[:org]}, false)['results'][0]
          if @api_error
            STDERR.puts "  ERROR: Unable to retrive subscription for #{desired_sub}"
          end

          desired_quantity = KatelloAttachSubscription::Utils.needed_entitlement(system_type, sys_socket, subs[desired_sub])
          puts "   The number of subscriptions needed for #{desired_sub} (id: #{subs[desired_sub]['id']}) is of #{desired_quantity}"

          # if there are not enough available subscriptions check the next available
          if desired_quantity > subs[desired_sub]['available'].to_i and subs[desired_sub]['quantity'].to_i != -1
            puts "   Cannot add subscription #{desired_sub} (id: #{subs[desired_sub]['id']}): only #{subs[desired_sub]['available']} available, but #{desired_quantity} requested"
            next
          end

          if @options[:subreport] and not has_derived_sub
            # count the sub to add, if not just present
            if @options[:debug]
              puts "      DEBUG: Current counted sub: #{sub_counted}"
            end
            # if not present, call addtototalsubneeded to add the count of subs
            if not sub_counted.include?(subs[desired_sub]['name'])
              skip_report = true
              addtototalsubneeded(system['name'], subs[desired_sub]['name'], desired_quantity)
              # add to the subs counted
              sub_counted.push(subs[desired_sub]['name'])
              sub_attached = true
            else
              # if just counted don't do nothing
              if @options[:debug]
                puts "      DEBUG: Skipping count as sub #{subs[desired_sub]['name']} is just present"
              end
            end
          end

          # if requirements are met, add the subscription
          puts "   adding #{desired_sub} for #{product} (id: #{subs[desired_sub]['id']})"

          # fix the number of the available and consumed subscription because this will be retrieved only once
          subs[desired_sub]['available'] -= desired_quantity
          subs[desired_sub]['consumed'] += desired_quantity

          if not @options[:noop]
            apiCall(:host_subscriptions, :add_subscriptions, {:host_id => system['id'], :subscriptions => [{:id => subs[desired_sub]['id'], :quantity => desired_quantity}]}, false)
            if @api_error
              STDERR.puts "  WARNING: Subscription problem -- unable to attach subscription for host #{system['id']} #{system['name']}"
            else
              puts "    Added #{desired_sub} for #{product} in system #{system['name']}"
              break
            end
          else
            puts "    [noop] Added #{desired_sub} for #{product} in system #{system['name']}"
            break
          end
        end

        # if no sub attached but needed, add to the count that you need the first one
        if @options[:subreport] and not has_derived_sub
          if not sub_attached
            # mark as missing the first desired_subs entry
            sub_missing = desired_subs_hash.first
            if @options[:verbose]
              puts "    VERBOSE: #{system['name']} didn't attach any #{product} sub, set that need #{sub_missing}"
            end
            missing_hash = subs[sub_missing]
            sub_socket = missing_hash['sockets']
            desired_quantity = KatelloAttachSubscription::Utils.needed_entitlement(system_type, sys_socket, missing_hash)
            if @options[:debug]
              puts "      DEBUG: Added #{desired_quantity} of #{missing_hash['name']} (#{missing_hash['name']}) for #{system['name']}"
            end
            addtototalsubneeded(system['name'], missing_hash['name'], desired_quantity)
            skip_report = true
          end
        end
      end
    end
  end

  # if auto-attach flag is set in YAML perform auto-attach for this hosts
  if auto_attach
    puts " auto-attaching subs to system #{system['name']}"
    if not @options[:noop]
      api.resource(:host_subscriptions).call(:auto_attach, {:host_id => system['id']})
      if @options[:subreport]
        # call function that get all the sub consumed and count only physical sub as stacked-derived are for unlimited guest
        addspecialsubtocount(system)
      end
    else
      puts " [noop] auto-attached"
    end
  end

  if system_type == KatelloAttachSubscription::FactAnalyzer::HYPERVISOR
    subscribe_guest(system['name'])
  end
end

# subscribe guest after hypervisor update, still wip as to implement new use_derived function
def subscribe_guest(hypervisor_name)
  search_options = "hypervisor_host=#{hypervisor_name}"
  hypervisor_guests = fetch_all_results(:hosts, :index, :search => search_options)
  if hypervisor_guests.count > 0
    if @options[:verbose]
      puts "VERBOSE: Hypervisor has #{hypervisor_guests.count} guests. Subscribing it."
    end
    hypervisor_guests.each do |hyp_guest|
      if @options[:verbose]
        puts "  VERBOSE: Assigning subscriptions to #{hyp_guest['name']}"
      end
      assignsubs(hyp_guest)
    end
  end
end

# add additional data from cluster retrieved by --check-density and --virt-who options
def add_cluster_data(sys)
  # add virt-who data to hypervisor
  sys = KatelloAttachSubscription::VirtWhoHelper.merge_system_virtwho(sys, @parsed_hypervisors_hash, @options[:org])
  # add calculated cluster data from --check-density options
  this_system_cluster = 'nil'
  if @options[:density]
    # retrieve cluster name of the hypervisor
    if sys.has_key?('facts') and sys['facts'].has_key?('hypervisor::cluster')
      this_system_cluster = sys['facts']['hypervisor::cluster']
    end
    if this_system_cluster == 'nil'
      sys['facts'] ||= {}
      sys['facts']['hypervisor::cluster'] = this_system_cluster
    end
    if @options[:debug]
      puts "   DEBUG: system cluster: #{this_system_cluster}"
    end
    if this_system_cluster != "nil" and this_system_cluster != "none"
      cluster_index = @cluster_data.index{|scluster| scluster['cluster_name'] == sys['facts']['hypervisor::cluster']}
      if cluster_index
        cluster_data = @cluster_data[cluster_index]
        cluster_data.each do |key, value|
          sys['facts'] ||= {}
          key_name = "cluster_data::#{key}"
          sys['facts'][key_name] = value
        end
        if @options[:debug]
          puts "  DEBUG: All facts after cluster_data facts addition"
          p sys['facts']
        end
      end
    end
  end
end


# collect in @guest_list every guest with its host and cluster that would be print in :guestreportfile
def collectguestdata(hypervisor_hash, guests_list)
  # if has guest start report, if not report as no guest are present for passed hypervisor
  if hypervisor_hash['subscription_facet_attributes']['virtual_guests'].count > 0
    if @options[:verbose]
      puts "    DEBUG: #{hypervisor_hash['name']} has #{hypervisor_hash['subscription_facet_attributes']['virtual_guests'].count} guests. Start reporting"
    end
    # loop all the guest
    hypervisor_hash['subscription_facet_attributes']['virtual_guests'].each do |guest_data|
      # get os of the guest
      guest_position=guests_list.index{|sguest| sguest['name'] == guest_data['name']}
      if guest_position
        guest_os=guests_list[guest_position]['operatingsystem_name']
      end
      # create hash for every guest with name, hypervisor name and hypervisor cluster
      guest_hash = {}
      guest_hash['name'] = guest_data['name']
      guest_hash['host'] = hypervisor_hash['name']
      guest_hash['cluster'] = hypervisor_hash['facts']['hypervisor::cluster']
      guest_hash['operating_system'] = guest_os
      @guest_list.push(guest_hash)
    end
  else
    if @options[:verbose]
      puts "    VERBOSE: #{hypervisor_hash['name']} has no guests. Skip from report"
    end
    # create hash that set "no guest" as name, hypervisor name and hypervisor cluster
    guest_hash = {}
    guest_hash['name'] = "No Guest"
    guest_hash['host'] = hypervisor_hash['name']
    guest_hash['cluster'] = hypervisor_hash['facts']['hypervisor::cluster']
    guest_hash['operating_system'] = ""
    @guest_list.push(guest_hash)
  end
end

# print in :guestreportfile the report for every record contained in @guest_list which contain hosts and cluster data for a virtual guests
def printguestreport()
  if @options[:verbose]
    puts "    VERBOSE: Printing guest report in #{@options[:guestreportfile]}"
  end
  CSV.open(@options[:guestreportfile], "wb", {:col_sep => ";"}) do |csv|
    # header of csv
    csv << ["Guest Name","Host Name","Cluster Name", "Operative System"]
    @guest_list.each do |guest_data|
      csv << [guest_data['name'], guest_data['host'], guest_data['cluster'], guest_data['operating_system']]
    end
  end
end

# return true if an hypervisor has guest on it, checking from satellite data passed
def hypervisor_has_guests(hostdata)
  has_guests = false
  # check if virtual_guests array in subscription_facet_attributes has elements
  if @options[:verbose]
    puts "    VERBOSE: Checking if #{hostdata['name']} has virtual_guests on it."
  end
  # if virtual_guests array has element on it set has_guest to true
  if hostdata["subscription_facet_attributes"].has_key?("virtual_guests") and hostdata["subscription_facet_attributes"]["virtual_guests"].count > 0
    if @options[:verbose]
      puts "      VERBOSE: #{hostdata["name"]} has #{hostdata["subscription_facet_attributes"]["virtual_guests"].count} guests"
    end
    has_guests = true
  else
    # else set has_guest to false
    if @options[:verbose]
      puts "      VERBOSE: #{hostdata["name"]} has no guests in it"
    end
    has_guests = false
  end
  return has_guests
end

# clean attached subs of the same products from a content-hosts
def clean_same_product (desired_sub_hash, host_subscriptions, host, host_type, host_socket)
  desired_sub_hash.each do |product, desired_product_sub_array|
    puts "Start checking if there are multiple #{product} subscriptions attached to #{host["name"]}"
    remove_subscription = []
    fit_subscription = nil
    host_subscriptions.each do |single_sub|
      # puts "DEBUGGONE DESIRED_SUB: #{desired_product_sub_array} - CP_ID: #{single_sub["cp_id"]}"
      sub_count = desired_product_sub_array.count(single_sub["cp_id"]).to_i
      if single_sub["type"] == "STACK_DERIVED" or sub_count <= 0
        next
      end
      if not fit_subscription
        needed_entitlement = KatelloAttachSubscription::Utils.needed_entitlement(host_type, host_socket, single_sub)
        attached_entitlement = single_sub["quantity_consumed"]
        if needed_entitlement >= attached_entitlement
          fit_subscription = single_sub["cp_id"]
        else
          remove_subscription.push(single_sub["id"])
        end
      else
        remove_subscription.push(single_sub["id"])
      end
    end
    puts "#{product} subscriptions that will be removed"
    p remove_subscription
    remove_subscription.each do |subscription|
      if not @options[:noop]
        apiCall(:host_subscriptions, :remove_subscriptions, {:host_id => host['id'], :subscriptions => [{:id => subscription}]}, false )
        if not @api_error
          puts "  removed subscription ID #{subscription}"
        else
          puts "  WARNING: Problem removing subscription ID #{subscription} from host #{host['name']} - ID #{host['id']}"
        end
      else
        puts "  [noop] removed subscriptions ID #{subscription}"
      end
    end
  end
end

# add the value of sub passed in sub_quantity to the sub passed in sub_name in subs_count hash
# def addtototalsubneeded(sub_name, sub_quantity)
def addtototalsubneeded(hostname, sub_name, sub_quantity, type = "")
  if @options[:verbose]
    puts "    VERBOSE: Adding #{sub_quantity} to needed quantity of subscription #{sub_name}"
  end
  # if sub_name not exists, add with 0
  if not @subs_count.has_key?(sub_name)
    @subs_count[sub_name] = 0
  end
  # add the count to the sub passed
  @subs_count[sub_name] += sub_quantity

  # added detailed report data
  detailed_entry = {}
  detailed_entry['hostname'] = hostname
  detailed_entry['subname'] = sub_name
  detailed_entry['quantity'] = sub_quantity
  detailed_entry['type'] = type
  @detailed_report.push(detailed_entry)
end

# create the CSV file that report the subscription count
def printsubsreport()
  if @options[:verbose]
    puts "    VERBOSE: Printing subscription status"
  end
  CSV.open(@options[:subreportfile], "wb", {:col_sep => ";"}) do |csv|
    # header of csv
    csv << ["Subscription Name","Expected Entitlement","Entitlement Available","Entitlement Consumed","Entitlement Free", "State"]
    @subs_count.each do |sub_name, sub_count|
      sub_hash = getsubdetailfor(sub_name)
      count_state = "OK"
      if sub_count.to_i > sub_hash["available"].to_i
        count_state = "ERROR"
      end
      csv << [sub_name, sub_count, sub_hash["available"], sub_hash["consumed"], sub_hash["free"], count_state]
    end

    csv << [""]
    csv << [""]

    csv << ["Subscription Name", "Instance Multiplier", "Expected Subscription", "Subscription Available", "Subscription Consumed", "Subscription Free", "State"]
    @subs_count.each do |sub_name, sub_count|
      sub_hash = getsubdetailfor(sub_name)
      count_state = "OK"
      instance_multiplier = 1
      if @exception_sub.include?(sub_name)
        instance_multiplier = 2
      end
      sub_count = (sub_count.to_f/instance_multiplier.to_f).ceil
      sub_available = (sub_hash["available"].to_f/instance_multiplier.to_f).ceil
      sub_consumed = (sub_hash["consumed"].to_f/instance_multiplier.to_f).ceil
      sub_free = sub_available - sub_consumed
      if sub_count > sub_available
        count_state = "ERROR"
      end
      csv << [sub_name, instance_multiplier, sub_count, sub_available, sub_consumed, sub_free, count_state]
    end
  end
  CSV.open(@options[:detailedsubreportfile], "wb", {:col_sep => ";"}) do |csv|
    # header of csv
    csv << ["Server Name", "Expected Subscription", "Expected Quantity", "Type"]
    @detailed_report.each do |sub_entry|
      csv << [sub_entry["hostname"], sub_entry["subname"], sub_entry["quantity"], sub_entry["type"]]
    end
  end
  CSV.open(@options[:detailedsubreportfile], "wb", {:col_sep => ";"}) do |csv|
    # header of csv
    csv << ["Server Name", "Expected Subscription", "Expected Quantity"]
    @detailed_report.each do |sub_entry|
      csv << [sub_entry["hostname"], sub_entry["subname"], sub_entry["quantity"], sub_entry["type"]]
    end
  end
end

# get all the subscriptions of the hosts for special case as:
# - hosts that would be auto attached
def addspecialsubtocount(system)
  system_id = system['id']
  attached_subscriptions = []
  # retrieve all the subscription attached
  response = apiCall(:host_subscriptions, :index, {:host_id => system_id}, false)
  if @api_error
    puts "   ERROR: Unknow Error -- Unable to retrieve subscription details for hypervisor #{system_id}"
  end
  # check if data found (API return data successfully)
  if not response.has_key?("total")
    if @options[:verbose]
      puts "    VERBOSE: Skipping Hypervisor as not valid data was retrieved from API"
    end
  else
    # check if total > 0, then loop the result to remove the subscriptions
    if response["total"].to_i > 0
      response["results"].each_with_index do |attached_sub, sub_index|
        if @options[:verbose]
          puts "      VERBOSE: Counting attached subscription #{sub_index+1} / #{response["total"].to_i} - #{attached_sub['id']}"
        end
        addtototalsubneeded(system['name'], attached_sub['name'], attached_sub['quantity_consumed'], attached_sub['type'])
      end
    end
  end
end

# count the total number of subs available, consumed and free
def getsubdetailfor(sub_name)
  detail_hash = {"consumed" => 0, "free" => 0}
  search_options = KatelloAttachSubscription::Utils.search_args(name: sub_name)
  parsed_subscription = fetch_all_results(:subscriptions,:index,{:search => search_options, :available_for => "host"})
  detail_hash["available"] = getavailablesubfor(parsed_subscription)
  detail_hash["consumed"] = getconsumedsubfor(parsed_subscription)
  detail_hash["free"] = getfreesubfor(parsed_subscription)
  return detail_hash
end

# count the total number of subs free to be consumed
def getfreesubfor(parsed_subscription)
  free_subs = 0
  if parsed_subscription.empty?
    puts "    Subscription entry is empty, not counting any free subscription"
    return free_subs
  end
  # if empty, so zero results, this will be simply skipped
  parsed_subscription.each do |subscription|
    # Check type of sub 'normal'
    if subscription.has_key?('type') and subscription['type'] != 'NORMAL'
      if @options[:debug]
        puts "   Skipping '#{subscription['cp_id']}' as sub type '#{subscription['type']}' is different from desired 'NORMAL'"
      end
      # if the filter do not match, skip to next subscription
      next
    end
    if subscription['available'].to_i < 0
      if @options[:debug]
        puts "     Skipping #{subscription['id']} as available subs are < 0"
      end
      next
    end
    # add the subs to the total free
    free_subs += subscription['available']
  end
  return free_subs
end

# return the quantity of the consumed subscriptions
def getconsumedsubfor(parsed_subscription)
  consumed_subs = 0
  if parsed_subscription.empty?
    puts "    Subscription entry is empty, not counting any free subscription"
    return consumed_subs
  end
  # if empty, so zero results, this will be simply skipped
  parsed_subscription.each do |subscription|
    # Check type of sub 'normal'
    if subscription.has_key?('type') and subscription['type'] != 'NORMAL'
      if @options[:debug]
        puts "   DEBUG: Skipping '#{subscription['cp_id']}' as sub type '#{subscription['type']}' is different from desired 'NORMAL'"
      end
      # if the filter do not match, skip to next subscription
      next
    end
    if subscription['consumed'].to_i < 0
      if @options[:debug]
        puts "     DEBUG: Skipping #{subscription['id']} as consumed subs are < 0"
      end
      next
    end
    # add the subs to the total consumed
    consumed_subs += subscription['consumed']
  end
  return consumed_subs
end

# return the quantity of the consumed subscriptions
def getavailablesubfor(parsed_subscription)
  available_subs = 0
  if parsed_subscription.empty?
    puts "    Subscription entry is empty, not counting any free subscription"
    return available_subs
  end
  # if empty, so zero results, this will be simply skipped
  parsed_subscription.each do |subscription|
    # Check type of sub 'normal'
    if subscription.has_key?('type') and subscription['type'] != 'NORMAL'
      if @options[:debug]
        puts "   DEBUG: Skipping '#{subscription['cp_id']}' as sub type '#{subscription['type']}' is different from desired 'NORMAL'"
      end
      # if the filter do not match, skip to next subscription
      next
    end
    if subscription['quantity'].to_i < 0
      if @options[:debug]
        puts "     DEBUG: Skipping #{subscription['id']} as consumed subs are < 0"
      end
      next
    end
    # add the subs to the total available
    available_subs += subscription['quantity']
  end
  return available_subs
end

# fetch all the hosts reading from the yaml configuration file, if present
def fetch_all_systems
  systems = []
  cachefile = @options[:cachefile].to_s + "_org" + @options[:org].to_s
  if @options[:usecache]
    puts "Starting host collection from cache. Please be patient."
    cachefile = "#{@options[:cachefile]}_org#{@options[:org]}"
    systems = readfromcache(cachefile, 'systems')
  else
    # no cache wanted
    puts "Starting host collection from API. Please be patient."
    # first of all, search for hypervisor as we would like to subscribe in order hypervisors, physicals and guests
    # Currently there is a BZ opened as is not possible to absolute search hypervisor, physical and guest (BZ1635861)
    if @options[:multisearch]
      search_data = @yaml[:search]
      search_data.each do |search_data|
        search_options = search_data
        puts "Searching for Hosts that match #{search_options}"
        systems.concat(fetch_all_results(:hosts, :index, {:search => search_options}))
      end
    else
      search_options = ""
      puts "Searching for all Hosts in the environment"
      systems = fetch_all_results(:hosts, :index, {:search => search_options})
    end
    hosts_count = systems.count
    puts "Completed hosts collection."
    puts "Hosts entry: #{hosts_count}"
  end
  return systems
end

# call api function to retrieve the list of object passed in resource
def fetch_all_results(resource, action, params)
  page = 0
  req = nil
  results = []
  while (page == 0 or req['results'].length == req['per_page'].to_i)
    # increase page counter
    page += 1
    # get 100 results
    params.merge!({:organization_id => @options[:org], :page => page, :per_page => 100})
    req = apiCall(resource, action, params, true)
    # concatenate output - all of the results
    results.concat(req['results'])
  end
  return results
end

# perform an api call checking for error and retry if setted
def apiCall(resource, action, params, exiting)
  if not @options[:repeatAPI]
    @options[:maxstep] = 1
  end
  @api_error = true
  current_step = 0
  exceptions_list = []
  results = {}
  step = 0
  while @api_error and step <= @options[:maxstep]
    begin
      results = @api.resource(resource).call(action, params)
      @api_error = false
    rescue RestClient::ExceptionWithResponse => exception
      @api_error = true
      step = step + 1
      exceptions_list.push({"time"=> Time.now, "step" => step, "message" => exception.message, "response" => exception.response })
      if @options[:debug]
        puts "DEBUG: API #{resource} / #{action} failes for the #{step} time(s)."
      end
      if @options[:sleepAPI]
        waiting_time = @options[:sleepTime] * ( @options[:sleepMult].to_f ** (step - 1) )
        if @options[:debug]
          puts "  DEBUG: waiting #{waiting_time} to repeat API call"
        end
        sleep(waiting_time)
      end
    end
  end
  if @options[:debug] and exceptions_list.count > 0
    apiCallPrintError(resource, action, params, step, exceptions_list)
  end
  if step >= @options[:maxstep] and exiting
    puts "Exiting from program"
    exit 1
  end
  return results
end

# print the error of the API call if present
def apiCallPrintError(resource, action, params, step, exceptions_list)
  STDERR.puts "###"
  STDERR.puts "ERROR: API Call failed for #{step} time(s). See error log:"
  STDERR.puts "API #{resource} / #{action} with this parameters"
  STDERR.puts params
  exceptions_list.each do |single_exception|
    STDERR.puts "---"
    STDERR.puts "FAIL ##{single_exception["step"].to_i}: #{single_exception["time"]} - #{single_exception["message"]}"
    STDERR.puts "#{single_exception["response"]}"
  end
  STDERR.puts "###"
end

# read the cache searching for key in file, if cachekey isn't setted read as json cachefile
def readfromcache(cachefile, cachekey)
  result = nil
  if not File.file?(cachefile)
    puts "FATAL ERROR: --read-from-cache option requested, but the cache file is not currently present."
    exit 5
  end
  if not cachekey.empty?
    result = []
    result = readfromYAMLcache(cachefile, cachekey)
  else
    result = {}
    result = readfromJSONcache(cachefile)
  end
  if @options[:debug]
    p result
  end
  return result
end

# read the array of object saved in 'yamlkey' for a yaml cachefile
def readfromYAMLcache(yamlcachefile, yamlkey)
  cache_result = []
  begin
    cacheyaml = YAML.load_file(yamlcachefile)
    cache_result = cacheyaml[yamlkey]
  rescue Exception
    abort "FATAL ERROR: Failed to read #{yamlkey} from #{yamlcachefile} cache file. re-run without --read-from-cache."
  end
  return cache_result
end

# read the json content from the cache file passed in cache_file
def readfromJSONcache(jsoncachefile)
  cache_result = {}
  begin
    raw_json = File.read(jsoncachefile)
    cache_result = JSON.parse(raw_json)
  rescue Exception
    abort "FATAL ERROR: Failed to read json #{jsoncachefile} cache file. re-run without --read-from-cache."
  end
  return cache_result
end

checksubs
subsupdate
